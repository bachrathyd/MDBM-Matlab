\documentclass[11pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath, amssymb, amsfonts}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}
\usepackage{booktabs}
\usepackage{geometry}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{longtable}

\geometry{margin=2.5cm}

\definecolor{mygreen}{RGB}{28,172,0}
\definecolor{mylilas}{RGB}{170,55,241}

\lstset{language=Matlab,
    breaklines=true,
    morekeywords={matlab2tikz},
    keywordstyle=\color{blue},
    commentstyle=\color{mygreen},
    stringstyle=\color{mylilas},
    basicstyle=\ttfamily\small,
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=10pt,
    backgroundcolor=\color{white},
    tabsize=4,
    showspaces=false,
    showstringspaces=false
}

\title{Multi-Dimensional Bisection Method (MDBM) \\ User's Guide}
\author{Dr. Daniel Bachrathy \\ \small Assistant Professor \\ \small Budapest University of Technology and Economics}
\date{February 2026}

\begin{document}

\maketitle

\tableofcontents

\newpage

\section{Introduction}
The Multi-Dimensional Bisection Method (MDBM) is an efficient and robust root-finding algorithm for determining high-dimensional submanifolds of the roots of implicit non-linear equation systems. It is particularly powerful in cases where the number of unknowns surpasses the number of equations ($k \leq l$):
\begin{equation}
    f_i(x_j) = 0, \quad i=1 \dots k, \quad j=1 \dots l
\end{equation}

MDBM iteratively halves the parameter space and evaluates only those grid points where a root is likely to exist, significantly reducing the number of required function evaluations compared to brute-force methods.

\section{Quick How-To-Use}
To use MDBM, you need to define the parameter space, the vectorized function, and the number of iterations.

\begin{lstlisting}
% 1. Define axes
ax(1).val = linspace(-3, 3, 10);
ax(2).val = linspace(-3, 3, 10);

% 2. Define vectorized function
foo = @(x) x(1,:).^2 + x(2,:).^2 - 4; % Unit circle

% 3. Run MDBM
Niteration = 4;
sol = mdbm(ax, foo, Niteration);

% 4. Plot
plot_mdbm(sol);
\end{lstlisting}

\section{Detailed Options (mdbmset)}
The behavior of the solver is controlled by the \texttt{mdbmset} structure. Each field is critical for fine-tuning the solver's performance and robustness.

\begin{longtable}{llp{6cm}}
\toprule
\textbf{Field} & \textbf{Related Demo} & \textbf{Description} \\ \midrule
\texttt{isconstrained} & \nameref{sec:constrain} & If true, the last equation in the output is treated as a domain boundary. Solutions are only kept where this value is positive. \\
\texttt{interporder} & \nameref{sec:interp} & Order of root interpolation: 0 (raw grid points), 1 (linear), 2 (quadratic). \\
\texttt{bracketingdistance} & \nameref{sec:bracketing} & Distance (in grid units) to look for sign changes. Helps recover branches in dense regions. \\
\texttt{bracketingnorm} & \nameref{sec:bracketing} & The norm used to calculate distance for bracketing. \\
\texttt{checkneighbour} & \nameref{sec:neighbor} & Max consecutive neighbor check steps. Set to \texttt{Inf} for max robustness. \\
\texttt{refinetype} & \nameref{sec:refine} & Refinement strategy: \texttt{'all'}, \texttt{'pos'} (range), \texttt{'object'} (near roots). \\
\texttt{zerotreshold} & Feature: Degenerate & Numerical value below which a function evaluation is considered exactly zero. \\
\texttt{connections} & \nameref{sec:connection} & If true, calculates the Delaunay connectivity needed for plotting surfaces and curves. \\
\texttt{timelimit} & Case: Mathieu & Max allowed time (seconds) for a single refinement step. \\
\texttt{funcallimit} & - & Max function evaluations allowed to prevent memory overflow. \\
\bottomrule
\end{longtable}

\section{Software Components (src)}
The following files in the \texttt{src/} directory form the core of the MDBM ecosystem:

\begin{longtable}{lp{9cm}}
\toprule
\textbf{File} & \textbf{Description} \\ \midrule
\texttt{mdbm.p} & \textbf{Main Entry Point}. Orchestrates iterative bisection, calling refinement and interpolation. \\
\texttt{mdbmset.m} & \textbf{Configuration}. Utility to create the options structure with defaults. \\
\texttt{plot\_mdbm.m} & \textbf{Visualization}. Intelligent plotting for 1D, 2D, and 3D submanifolds. \\
\texttt{extend\_axis.m} & \textbf{Domain Extension}. Adds new parameter ranges to an existing solution. \\
\texttt{refine.p} & \textbf{Grid Management}. Implements the various refinement strategies. \\
\texttt{checkneighbour.p} & \textbf{Robustness Engine}. Scans adjacent grid cells to find missing branches. \\
\texttt{interpolating\_cubes.p} & \textbf{Root Finder}. Performs root interpolation within a grid cell. \\
\texttt{DTconnect.p} & \textbf{Meshing}. Standard Delaunay triangulation for result visualization. \\
\texttt{interpplot.p} & \textbf{Smoothing}. Generates high-quality interpolation for plotting. \\
\texttt{plotthecomputedpoints.m} & \textbf{Debug Viz}. Visualizes all grid points evaluated by the solver. \\
\bottomrule
\end{longtable}

\section{History}
The core idea of MDBM occurred during my MSc thesis (written during an Erasmus stay at the University of Bristol - thank you for that!) in 2006. It has been updated in larger and smaller bursts throughout the last 20 years, leading to my most cited paper.

The primary motivation was the solution of the characteristic equations of Delay Differential Equations (DDEs), which typically involve 2+1 parameters and 2 equations (real and imaginary parts of the characteristic equation). At that time, no direct method existed to solve these automatically in a robust way, especially for detecting closed manifolds of non-differentiable functions. As far as I know, there is still no other method that handles this as effectively.

\section{Disclaimer}
\textbf{Note on Protected Files}: I would like to protect my work, thus I use \texttt{*.p} files for the core engine (some of you may dislike it, sorry). In my opinion, the code is far too long and complex to understand; I spent more than 10 years on it, and sometimes it is hard even for me to understand the logic! (I am a mechanical engineer, not a professional programmer). However, all files that might need modification for special needs are provided as \texttt{*.m} files. 

\textbf{Julia Version}: A newer version is available in Julia. Although not all features from the Matlab version have been migrated yet (as some are not critical), they have similar capabilities. Currently, only the Julia version is being actively maintained and updated, so great new features will come there first. For instance, sub-cube interpolation is already available, and the error-based non-uniform refinement (``best and most needed feature ever'') is already in a usable beta version.

\section{Known Alternatives}
\begin{itemize}
    \item \textbf{Mathematica (ContourPlot/Isosurface)}: Mathematica performs contour plots by iteratively refining the grid (triangle-based), which is similar to my method. As far as I know, it does this in 3D as well. However, it can generally handle only one equation (which is the ``easy'' problem).
    \item \textbf{Sequential Projections}: There are versions where you solve the first equation in higher dimensions, then triangulate the result, and solve the second equation on that mesh, and so on. While this creates a robust solution, the complexity is very, very high---almost the same as a brute-force search.
    \item \textbf{Interval Arithmetic}: Some methods provide guaranteed solutions (whereas in MDBM, it is inevitable that a small piece of the solution might be lost in higher dimensions---in contrast to the traditional 1D bisection problem). See the great works of \textbf{David P. Sanders} on Interval Arithmetic (e.g., \texttt{IntervalRootFinding.jl} in Julia).
\end{itemize}

\section{Folder Descriptions and Gallery}

\subsection{Features (features/)}
\subsubsection{Simplex Connections}\label{sec:connection}
\texttt{connection\_of\_points\_to\_simplex.m} shows how points are connected (Figure~\ref{fig:connection}).
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.6\textwidth]{../figures/feature_connection.png}
    \caption{Connectivity of points in the parameter space.}
    \label{fig:connection}
\end{figure}

\subsubsection{Constrained Problems}\label{sec:constrain}
Handling domain boundaries (Figure~\ref{fig:const_simple} and~\ref{fig:const_complex}).
\begin{figure}[htbp]
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{../figures/feature_constraints_simple.png}
        \caption{Simple constraint.}
        \label{fig:const_simple}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{../figures/feature_constraints_complex.png}
        \caption{Complex combined constraints.}
        \label{fig:const_complex}
    \end{subfigure}
    \caption{Constraint handling in MDBM.}
\end{figure}

\subsubsection{Interpolation Order}\label{sec:interp}
Comparison of 0th, 1st, and 2nd order (Figure~\ref{fig:interp_order}).
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{../figures/feature_interpolation_order.png}
    \caption{Effect of interpolation order on accuracy and convergence.}
    \label{fig:interp_order}
\end{figure}

\subsubsection{Local Refinement}\label{sec:refine}
Zooming into regions (Figure~\ref{fig:refine}).
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.6\textwidth]{../figures/feature_local_refinement.png}
    \caption{Local refinement of a non-smooth boundary.}
    \label{fig:refine}
\end{figure}

\subsubsection{Neighbor Check}\label{sec:neighbor}
Recovering missing branches (Figure~\ref{fig:neighbor}).
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.6\textwidth]{../figures/feature_neighbor_check.png}
    \caption{Neighbor check ensuring solution continuity.}
    \label{fig:neighbor}
\end{figure}

\subsubsection{Bracketing n-cubes}\label{sec:bracketing}
\texttt{bracketing\_ncube\_detection.m} shows how bracketing cells are identified (Figure~\ref{fig:bracketing}). This script demonstrates the effect of the \texttt{bracketingdistance} parameter by performing a sweep across different values, highlighting the trade-off between capturing disconnected manifold components and the number of evaluated grid points.
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.9\textwidth]{../figures/feature_bracketing.png}
    \caption{Bracketing n-cube detection with varying \texttt{bracketingdistance} values.}
    \label{fig:bracketing}
\end{figure}

\newpage
\subsection{Examples (examples/)}
\begin{figure}[htbp]
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{../figures/example_unit_circles.png}
        \caption{Unit circles ($L^p$ norms).}
        \label{fig:ex_circles}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{../figures/example_julia_3d.png}
        \caption{3D Julia set.}
        \label{fig:ex_julia}
    \end{subfigure}
    \caption{Geometric and fractal examples.}
\end{figure}

\subsection{Case Studies (case\_studies/)}
\begin{figure}[htbp]
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{../figures/case_shimmy.png}
        \caption{Shimmy vibration stability.}
        \label{fig:case_shimmy}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{../figures/case_turning.png}
        \caption{Turning stability chart.}
        \label{fig:case_turning}
    \end{subfigure}
    \caption{Engineering case studies.}
\end{figure}

\section{Citing}
If you use MDBM in your research, please cite:
\textit{Bachrathy, Daniel, and Gabor Stepan. ``Bisection Method in Higher Dimensions and the Efficiency Number.'' Periodica Polytechnica Mechanical Engineering, 2012.}

\end{document}